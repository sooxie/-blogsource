(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{184:function(e,n,r){"use strict";r.r(n);var a=r(0),t=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,n=e.$createElement,r=e._self._c||n;return r("div",{staticClass:"content"},[r("h1",{attrs:{id:"weak"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#weak","aria-hidden":"true"}},[e._v("#")]),e._v(" weak")]),e._v(" "),r("h3",{attrs:{id:"weak的初始化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#weak的初始化","aria-hidden":"true"}},[e._v("#")]),e._v(" weak的初始化")]),e._v(" "),r("div",{staticClass:"language-objc extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("\n/\n *\n * @param location Address of __weak ptr.  弱指针地址\n * @param newObj Object ptr.    弱指针指向的对象\n */\n\nid\nobjc_initWeak(id *location, id newObj)\n{\n    if (!newObj) {\n        *location = nil;\n        return nil;\n    }\n\n    return storeWeak<DontHaveOld, DoHaveNew, DoCrashIfDeallocating>\n        (location, (objc_object*)newObj);\n}\n\n\n\n")])])]),r("p",[e._v("NSObject.mm")]),e._v(" "),r("div",{staticClass:"language-objc extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("- (void)dealloc {\n    _objc_rootDealloc(self);\n}\n\nvoid\n_objc_rootDealloc(id obj)\n{\n    assert(obj);\n\n    obj->rootDealloc();\n}\n\ninline void\nobjc_object::rootDealloc()\n{\n  //是否为TaggedPointer指针，加快释放数独\n    if (isTaggedPointer()) return;  // fixme necessary?\n\n    if (fastpath(isa.nonpointer  &&  \n                 !isa.weakly_referenced  &&  \n                 !isa.has_assoc  &&  \n                 !isa.has_cxx_dtor  &&  \n                 !isa.has_sidetable_rc))\n    {\n        assert(!sidetable_present());\n        free(this);\n    } \n    else {\n        object_dispose((id)this);\n    }\n}\n\n\nid \nobject_dispose(id obj)\n{\n    if (!obj) return nil;\n\n    objc_destructInstance(obj);    \n    free(obj);\n\n    return nil;\n}\n\n\n/***********************************************************************\n* objc_destructInstance\n* Destroys an instance without freeing memory. 在不释放内存的情况下销毁实例\n* Calls C++ destructors.\n* Calls ARC ivar cleanup.\n* Removes associative references.\n* Returns `obj`. Does nothing if `obj` is nil.\n**********************************************************************/\nvoid *objc_destructInstance(id obj) \n{\n    if (obj) {\n        // Read all of the flags at once for performance.\n        // 是否有c++析构函数\n        bool cxx = obj->hasCxxDtor();\n        // 是否有关联对象，如果有则移除\n        bool assoc = obj->hasAssociatedObjects();\n\n        // This order is important.\n        if (cxx) object_cxxDestruct(obj);\n        if (assoc) _object_remove_assocations(obj);\n        obj->clearDeallocating();\n    }\n\n    return obj;\n}\n\n\n\n")])])]),r("div",{staticClass:"language-objc extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('\n//清除弱引用\ninline void \nobjc_object::clearDeallocating()\n{\n    if (slowpath(!isa.nonpointer)) {\n        // Slow path for raw pointer isa.\n        sidetable_clearDeallocating();\n    }\n    else if (slowpath(isa.weakly_referenced  ||  isa.has_sidetable_rc)) {\n        // Slow path for non-pointer isa with weak refs and/or side table data.\n        clearDeallocating_slow();\n    }\n\n    assert(!sidetable_present());\n}\n\nNEVER_INLINE void\nobjc_object::clearDeallocating_slow()\n{\n    assert(isa.nonpointer  &&  (isa.weakly_referenced || isa.has_sidetable_rc));\n\n    SideTable& table = SideTables()[this];\n    table.lock();\n    if (isa.weakly_referenced) {\n        weak_clear_no_lock(&table.weak_table, (id)this);\n    }\n    if (isa.has_sidetable_rc) {\n        table.refcnts.erase(this);\n    }\n    table.unlock();\n}\n\n\n//objc-weak.mm\nvoid \nweak_clear_no_lock(weak_table_t *weak_table, id referent_id) \n{\n    objc_object *referent = (objc_object *)referent_id;\n\n    weak_entry_t *entry = weak_entry_for_referent(weak_table, referent);\n    if (entry == nil) {\n        /// XXX shouldn\'t happen, but does with mismatched CF/objc\n        //printf("XXX no entry for clear deallocating %p\\n", referent);\n        return;\n    }\n\n    // zero out references\n    weak_referrer_t *referrers;\n    size_t count;\n    \n    if (entry->out_of_line()) {\n        referrers = entry->referrers;\n        count = TABLE_SIZE(entry);\n    } \n    else {\n        referrers = entry->inline_referrers;\n        count = WEAK_INLINE_COUNT;\n    }\n    \n    for (size_t i = 0; i < count; ++i) {\n        objc_object **referrer = referrers[i];\n        if (referrer) {\n            if (*referrer == referent) {\n                *referrer = nil;\n            }\n            else if (*referrer) {\n                _objc_inform("__weak variable at %p holds %p instead of %p. "\n                             "This is probably incorrect use of "\n                             "objc_storeWeak() and objc_loadWeak(). "\n                             "Break on objc_weak_error to debug.\\n", \n                             referrer, (void*)*referrer, (void*)referent);\n                objc_weak_error();\n            }\n        }\n    }\n    \n    weak_entry_remove(weak_table, entry);\n}\n\n\n\n')])])])])}],!1,null,null,null);t.options.__file="weak.md";n.default=t.exports}}]);